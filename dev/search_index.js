var documenterSearchIndex = {"docs":
[{"location":"api/","page":"api","title":"api","text":"Modules = [ACTRModels]\nOrder   = [:type, :function]\nPrivate = false","category":"page"},{"location":"api/#ACTRModels.ACTR","page":"api","title":"ACTRModels.ACTR","text":"ACTR(;\n    name=\"model1\", \n    declarative=Declarative(), \n    imaginal=Imaginal(), \n    goal = Goal(), \n    scheduler=Scheduler(), \n    visual=nothing, \n    visual_location=nothing, \n    procedural=nothing, \n    motor=nothing, \n    visicon=init_visicon(), \n    parm_type = Parms, \n    parms...)\n\nACTR model object\n\nFields\n\nname=\"model1\": model name\ndeclarative: declarative memory module\nimaginal: imaginal memory module\nvisual: visual module\ngoal: goal module\nvisual_location: visual location module\nvisicon: a vector of VisualObjects available in the task\nparms: model parameters\nscheduler: event scheduler\n\nExample\n\nusing ACTRModels\nparms = (noise=true, τ=-1.0)\nchunks = [Chunk(;animal=:dog,name=:Sigma), Chunk(;animal=:rat,name=:Bonkers)]\ndeclarative = Declarative(;memory=chunks)\nactr = ACTR(;declarative, parms...)\n\n\n\n\n\n","category":"type"},{"location":"api/#ACTRModels.BufferState","page":"api","title":"ACTRModels.BufferState","text":"BufferState(;busy, error, empty)\n\nAn object representing the state of the buffer.\n\nFields\n\nbusy=false: busy if true\nerror=false: error if true\nempty=true: empty if true\n\n\n\n\n\n","category":"type"},{"location":"api/#ACTRModels.Chunk","page":"api","title":"ACTRModels.Chunk","text":"Chunk\n\nAn object representing a declarative memory chunk.\n\nFields\n\nN=1.0: number of uses\nL=1.0: lifetime of chunk\ntime_created=0.0: time at which the chunk was created\nk=1: number of chunks in recent set (k=1 is sufficient)\nact=0.0: total activation\nact_blc=0.0: base level constant component of activation\nact_bll=0.0: base level learning component of activation\nact_pm=0.0: partial matching component of activation\nact_sa=0.0: spreading activation component of activation\nact_noise=0.0: noise component of activation\nslots: chunk slot-value pairs\nreps=0: number of identical chunks. This can be used in simple cases to speed up the code.\nrecent=[0.0]: time stamps for k recent retrievals\nlags=Float64[]: lags for recent retrievals (L - recent)\nbl=0.0: baselevel constant added to chunks activation\n\n\n\n\n\n","category":"type"},{"location":"api/#ACTRModels.Chunk-Tuple{Bool}","page":"api","title":"ACTRModels.Chunk","text":"Chunk(dynamic::Bool; \n    N = 1,\n    L = 1.0,\n    time_created = 0.0,\n    k = 1, \n    act = 0.0, \n    recent = [0.0],\n    reps = 0, \n    lags = Float64[], \n    bl = zero(typeof(act)),\n    slots...)\n\nA declarative memory chunk with dynamic slot-value pairs.\n\nFields\n\ndynamic::Bool: slot-value pairs are mutable if true\nN=1.0: number of uses\nL=1.0: lifetime of chunk\ntime_created=0.0: time at which the chunk was created\nk=1: number of chunks in recent set (k=1 is sufficient)\nact_mean: mean activation computed as act - act_noise\nact=0.0: total activation computed as act_mean + act_noise\nact_blc=0.0: base level constant component of activation\nact_bll=0.0: base level learning component of activation\nact_pm=0.0: partial matching component of activation\nact_sa=0.0: spreading activation component of activation\nact_noise=0.0: noise component of activation\nslots: chunk slot-value pairs\nreps=0: number of identical chunks. This can be used in simple cases to speed up the code.\nrecent=[0.0]: time stamps for k recent retrievals\nlags=Float64[]: lags for recent retrievals (L - recent)\nbl=0.0: baselevel constant added to chunks activation\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.Chunk-Tuple{}","page":"api","title":"ACTRModels.Chunk","text":"Chunk(;\n    N = 1,\n    L = 1.0,\n    time_created = 0.0,\n    k = 1, \n    act = 0.0, \n    recent = [0.0],\n    reps = 0, \n    lags = Float64[], \n    bl = zero(typeof(act)),\n    slots...)\n\nAn object representing a declarative memory chunk.\n\nKeywords\n\nN=1.0: number of uses\nL=1.0: lifetime of chunk\ntime_created=0.0: time at which the chunk was created\nk=1: number of chunks in recent set (k=1 is sufficient)\nact=0.0: total activation\nact_blc=0.0: base level constant component of activation\nact_bll=0.0: base level learning component of activation\nact_pm=0.0: partial matching component of activation\nact_sa=0.0: spreading activation component of activation\nact_noise=0.0: noise component of activation\nslots: chunk slot-value pairs\nreps=0: number of identical chunks. This can be used in simple cases to speed up the code.\nrecent=[0.0]: time stamps for k recent retrievals\nlags=Float64[]: lags for recent retrievals (L - recent)\nbl=0.0: baselevel constant added to chunks activation\n\nExample\n\nusing ACTRModels\n\nchunk = Chunk(; name = :Bonkers, animal = :rat)\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.Declarative","page":"api","title":"ACTRModels.Declarative","text":"Declarative(;memory=, filtered=(:isa,:retrieved))\n\nDeclarative memory module\n\nFields\n\nmemory=Chunk[]: array of chunks\nfiltered: slots that must match exactly even when partial matching is on. By default,    filtered=(:isa,:retrieved)\nbuffer: an array containing one chunk\nstate: buffer state\n\n\n\n\n\n","category":"type"},{"location":"api/#ACTRModels.Goal","page":"api","title":"ACTRModels.Goal","text":"Goal(;chunk=Chunk())\n\nGoal Module.\n\nFields\n\nbuffer: an array holding up to one chunk\nstate: buffer state\n\n\n\n\n\n","category":"type"},{"location":"api/#ACTRModels.Imaginal","page":"api","title":"ACTRModels.Imaginal","text":"Imaginal(;buffer=Chunk[], ω=1.0, denoms=Int64[])\n\nImaginal Module.\n\nFields\n\nbuffer: an array holding up to one chunk\nstate: buffer state\nω=1.0: fan weight. Default is 1.\ndenoms=Int64[]: cached value for the denominator of the fan calculation\n\n\n\n\n\n","category":"type"},{"location":"api/#ACTRModels.Motor","page":"api","title":"ACTRModels.Motor","text":"Motor(;chunk=Chunk())\n\nMotor Module.\n\nFields\n\nbuffer: an array holding up to one chunk\nstate: buffer state\nmouse_position: x,y coordinates of mouse position on screen\n\n\n\n\n\n","category":"type"},{"location":"api/#ACTRModels.Parms","page":"api","title":"ACTRModels.Parms","text":"Parms(; kwargs...) -> Parms\n\nACT-R parameters with default values. Default values are overwritten with keyword arguments.\n\nFields\n\nd=0.5: activation decay\nτ=0.0: retrieval threshold\ns=0.2: logistic scalar for activation noise.\nγ=1.6: maximum associative strength\nδ=0.0: mismatch penalty\nω=1.0: weight for source of spreading activation\nblc=0.0: base level constant\nter=0.0: a constant for encoding and responding time\ndissim_func: computes dissimilarity between two slot values. Output ranges from 0 (maximally similar) to 1 (maximially dissimilar)\nsa_fun: a function for spreading activation which requires arguments for actr and chunk\nutil_mmp_fun: utility mismatch penalty function applied to each condition\nlf=1.0: latency factor parameter\nu0=0.0: initial utility value\nσu=.2: standard deviation of utility noise \nδu=1.0: mismatch penalty parameter for utility\nτu0 = -100: initial value of utility threshold \n`τu = τu0': utility threshold \nu0Δ = 1.0: utility decrement\nτuΔ = 1.0: utility threshold decrement\nutility_decrement=1.0: the utility decrement scalar. After each microlapse, utility_decrement is multiplied by u0Δ\nthreshold_decrement=1.0: the threshold decrement scalar. After each microlapse, threshold_decrement is multiplied by τuΔ\nbll=false: base level learning on\nmmp=false: mismatch penalty on\nsa=false: spreading activatin on\nnoise=false: noise on\nmmp_utility=false: mismatch penalty for procedural memory\nutility_noise=false: utility noise for procedural memory\ntmp=s * √(2): temperature for blending\nmisc: NamedTuple of extra parameters\nfiltered: a list of slots that must absolutely match with mismatch penalty. isa and retrieval are included   by default\n\n\n\n\n\n","category":"type"},{"location":"api/#ACTRModels.Procedural","page":"api","title":"ACTRModels.Procedural","text":"Procedural\n\nProcedural Memory Module object.\n\nArguments\n\nbuffer: an array holding up to one chunk\nstate: buffer state\n\n\n\n\n\n","category":"type"},{"location":"api/#ACTRModels.Rule","page":"api","title":"ACTRModels.Rule","text":"Rule(;utlity=0.0, conditions, action)\n\nA production rule object.\n\nFields\n\nutility=0.0: utility of the production rule\ninitial_utility=0.0: initial utility\nutility_mean=0.0: mean utility\nutility_penalty=0.0: mismatch penalty term for utility \nutlity_noise=0.0: utility noise\nconditions: a function for checking conditions\naction: a function for performing an action\nname: name of production\n\n\n\n\n\n","category":"type"},{"location":"api/#ACTRModels.Visual","page":"api","title":"ACTRModels.Visual","text":"Visual(;chunk=Chunk())\n\nVisual Module.\n\nFields\n\nbuffer: an array holding up to one chunk\nstate: buffer state\nfocus: coordinates of visual attention\n\n\n\n\n\n","category":"type"},{"location":"api/#ACTRModels.VisualLocation","page":"api","title":"ACTRModels.VisualLocation","text":"VisualLocation\n\nVisual Location Module.\n\nFields\n\nbuffer::Array{T1,1}: an array holding up to one chunk\nstate::B: buffer state\niconic_memory::Array{T1,1}: a temporary memory store for visible objects\n\n\n\n\n\n","category":"type"},{"location":"api/#ACTRModels.VisualObject","page":"api","title":"ACTRModels.VisualObject","text":"VisualObject(;x=300.0, y=300.0, color=:black, text=\"\", shape=:_, width=30.0, height=30.0)\n\nA visible object in a task. \n\nFields\n\nx: x coordinate of visual object. Default 0.\ny: y coordinate of visual object. Default 0.\ncolor: object color\nshape: object shape\ntext: object text\nwidth: object width \nheight: object height \n\n\n\n\n\n","category":"type"},{"location":"api/#ACTRModels.add_chunk!-Tuple{AbstractACTR, Any}","page":"api","title":"ACTRModels.add_chunk!","text":"add_chunk!(actr::AbstractACTR, cur_time=0.0; slots...)\n\nAdds new chunk to declarative memory or updates existing chunk with new use\n\nArguments\n\nactr::AbstractACTR: an ACT-R model object\ncur_time=0.0: current simulated time in seconds\n\nKeywords\n\nslots...: optional keyword arguments corresponding to slot-value pairs, e.g. name=:Bob\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.add_chunk!-Tuple{AbstractACTR}","page":"api","title":"ACTRModels.add_chunk!","text":"add_chunk!(actr::AbstractACTR; slots...)\n\nAdds new chunk to declarative memory or updates existing chunk with new use. The default time is computed from get_time.\n\nArguments\n\nactr::AbstractACTR: an ACT-R model object\n\nKeywords\n\nslots...: optional keyword arguments corresponding to slot-value pairs, e.g. name=:Bob\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.add_chunk!-Union{Tuple{Declarative}, Tuple{T}, Tuple{Declarative, Any}} where T","page":"api","title":"ACTRModels.add_chunk!","text":"add_chunk!(memory::Declarative, cur_time=0.0; act=0.0, slots...)\n\nAdds new chunk to declarative memory or updates existing chunk with new use\n\nArguments\n\nmemory::Declarative: declarative memory object\ncur_time=0.0: current simulated time in seconds\nbl=0.0: baselevel constant for new/updated chunk\n\nKeywords\n\nslots...: optional keyword arguments corresponding to slot-value pairs, e.g. name=:Bob\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.add_time!-Tuple{AbstractACTR, Any}","page":"api","title":"ACTRModels.add_time!","text":"add_time!(actr::AbstractACTR, t)\n\nAdd time to simulation.\n\nArguments\n\nactr::AbstractACTR: an ACTR model object\nt: time in seconds\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.add_time!-Tuple{Any, Any}","page":"api","title":"ACTRModels.add_time!","text":"add_time!(actr::AbstractACTR, t)\n\nAdd time to simulation.\n\nArguments\n\nscheduler: an event scheduler\nt: time in seconds\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.blend_chunks-Tuple{AbstractACTR, Any, Any}","page":"api","title":"ACTRModels.blend_chunks","text":"blend_chunks(actr, blended_slots, cur_time; request...)\n\nComputes blended value over chunks given a retrieval request. Values are blended over the slots specified in blended_slots. Currently, blended is only supported  for numeric slot-values. \n\nArguments\n\nactr: an ACTR model object \nblended_slots: a set of slots over which slot-values are blended\ncur_time: current simulated time\n\nKeywords\n\nrequest...: optional keywords for the retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.blend_chunks-Tuple{AbstractACTR, Any}","page":"api","title":"ACTRModels.blend_chunks","text":"blend_chunks(actr::AbstractACTR, blended_slots; request...)\n\nComputes blended value over chunks given a retrieval request. By default,  values are blended over the set of slots formed by the set difference between all  slots of a chunk and the slots specified in the retrieval request. The default time used  in activation calculations is taken from get_time(actr). Currently, blended  is only supported for numeric slot-values. \n\nArguments\n\nactr::AbstractACTR: an ACTR model object \nblended_slots: a set of slots over which slot-values are blended\n\nKeywords\n\nrequest...: optional keywords for the retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.blend_chunks-Tuple{AbstractACTR, Float64}","page":"api","title":"ACTRModels.blend_chunks","text":"blend_chunks(actr::AbstractACTR, cur_time::Float64; request...)\n\nComputes blended value over chunks given a retrieval request. By default,  values are blended over the set of slots formed by the set difference between all  slots of a chunk and the slots specified in the retrieval request. Currently, blended  is only supported for numeric slot-values. \n\nArguments\n\nactr::AbstractACTR: an ACTR model object \ncur_time::Float64: current simulated time\n\nKeywords\n\nrequest...: optional keywords for the retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.blend_chunks-Tuple{AbstractACTR}","page":"api","title":"ACTRModels.blend_chunks","text":"blend_chunks(actr::AbstractACTR; request...)\n\nComputes blended value over chunks given a retrieval request. By default,  values are blended over the set of slots formed by the set difference between all  slots of a chunk and the slots specified in the retrieval request. The default time used  in activation calculations is taken from get_time. Currently, blended  is only supported for numeric slot-values. \n\nArguments\n\nactr::AbstractACTR: an ACTR model object \n\nKeywords\n\nrequest...: optional keywords for the retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.blend_chunks-Tuple{Any}","page":"api","title":"ACTRModels.blend_chunks","text":"blend_chunks(actr; request...)\n\nComputes blended value over chunks given a retrieval request. By default,  values are blended over the set of slots formed by the set difference between all  slots of a chunk and the slots specified in the retrieval request. The default time used  in activation calculations is taken from get_time. Currently, blended  is only supported for numeric slot-values. \n\nArguments\n\nactr::AbstractACTR: an ACTR model object \n\nKeywords\n\nrequest...: optional keywords for the retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.blended_activation-Tuple{Any}","page":"api","title":"ACTRModels.blended_activation","text":"blended_activation(chunks)\n\nComputes a blended activation value by exponentiating, summing and taking the  log of activations across a set of chunks.\n\nArguments\n\nchunks: a set of chunks over which slot-values are blended\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.compute_RT-Tuple{Any, Any}","page":"api","title":"ACTRModels.compute_RT","text":"compute_RT(actr, chunk)\n\nGenerates a reaction time for retrieving a chunk based on the current activation levels of a chunk. If the vector is empty, time  for a retrieval failure is returned.\n\nArguments\n\nactr: ACTR object\nchunk: a vector that is empty or contains one chunk\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.compute_RT-Tuple{Any, Chunk}","page":"api","title":"ACTRModels.compute_RT","text":"compute_RT(actr, chunk)\n\nGenerates a reaction time for retrieving a chunk based on the current activation levels of a chunk.\n\nArguments\n\nactr: ACTR object\nchunk: a chunk\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.compute_RT-Tuple{Any}","page":"api","title":"ACTRModels.compute_RT","text":"compute_RT(blended_act)\n\nComputes retrieval time for a given blended activation value.\n\nArguments\n\nblended_act: a blended activation value \n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.compute_activation!-Tuple{AbstractACTR, Float64}","page":"api","title":"ACTRModels.compute_activation!","text":"compute_activation!(actr::AbstractACTR, cur_time::Float64; request...)\n\nComputes the activation of all chunks in declarative memory\n\nArguments\n\nactr::AbstractACTR: an ACTR object\ncur_time: current simulated time in seconds\n\nKeywords\n\nrequest...: optional keywords for the retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.compute_activation!-Tuple{AbstractACTR, Vector{<:Chunk}, Float64}","page":"api","title":"ACTRModels.compute_activation!","text":"compute_activation!(actr::AbstractACTR, chunks::Vector{<:Chunk}, cur_time::Float64; request...)\n\nComputes the activation of a vector of chunks\n\nArguments\n\nactr::AbstractACTR: an ACTR object\nchunks::Vector{<:Chunk}: a vector of chunks.\ncur_time::Float64: current simulated time in seconds\n\nKeywords\n\nrequest...: optional keywords for the retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.compute_activation!-Tuple{AbstractACTR, Vector{<:Chunk}}","page":"api","title":"ACTRModels.compute_activation!","text":"compute_activation!(actr::AbstractACTR, chunks::Vector{<:Chunk}; request...)\n\nComputes the activation of a vector of chunks. By default, current time is computed with get_time.\n\nArguments\n\nactr::AbstractACTR: an ACTR object\nchunks::Vector{<:Chunk}: a vector of chunks.\n\nKeywords\n\nrequest...: optional keywords for the retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.compute_activation!-Tuple{AbstractACTR}","page":"api","title":"ACTRModels.compute_activation!","text":"compute_activation!(actr::AbstractACTR; request...)\n\nComputes the activation of all chunks in declarative memory. By default, current time is computed with get_time.\n\nArguments\n\nactr::AbstractACTR: an ACTR object\n\nKeywords\n\nrequest...: optional keywords for the retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.compute_activation!-Tuple{Any, Chunk, Any}","page":"api","title":"ACTRModels.compute_activation!","text":"compute_activation!(actr, chunk::Chunk, cur_time; request...)\n\nComputes the activation of a chunk\n\nArguments\n\nactr: actr object\nchunk::Chunk: a chunk.\ncur_time: current simulated time in seconds\n\nKeywords\n\nrequest...: optional keywords for the retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.compute_activation!-Tuple{Any, Chunk}","page":"api","title":"ACTRModels.compute_activation!","text":"compute_activation!(actr, chunk::Chunk; request...)\n\nComputes the activation of a chunk. By default, current time is computed  with get_time.\n\nArguments\n\nactr: actr object\nchunk::Chunk: a chunk.\n\nKeywords\n\nrequest...: optional keywords for the retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.find_index-Tuple{ACTR, Vararg{Any}}","page":"api","title":"ACTRModels.find_index","text":"find_index(actr::ACTR, funs...; check_value=true, criteria...)\n\nReturns the index of first chunk that matches a set of criteria\n\nArguments\n\nactr: ACTR object\nfuns: a set of functions\n\nKeywords\n\ncheck_value=true: \ncriteria: a set of keyword arguments for slot-value pairs\n\nExample\n\nchunks = [Chunk(animal=:dog), Chunk(animal=cat)]\nfind_index(chunks; animal=:dog)\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.find_index-Tuple{Vector{<:Chunk}, Vararg{Any}}","page":"api","title":"ACTRModels.find_index","text":"find_index(chunks::Array{<:Chunk,1}, funs...; check_value=true, criteria...)\n\nReturns the index of first chunk that matches a set of criteria\n\nArguments\n\nchunks: an array of chunks\nfuns: a set of functions\ncriteria: a set of keyword arguments for slot-value pairs\n\nKeywords\n\ncheck_value=true: \ncriteria: a set of keyword arguments for slot-value pairs\n\nchunks = [Chunk(animal=:dog), Chunk(animal=cat)]\nfind_index(chunks; animal=:dog)\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.find_index-Tuple{Vector{<:Chunk}}","page":"api","title":"ACTRModels.find_index","text":"find_index(chunks::Array{<:Chunk,1}; check_value=true, criteria...)\n\nReturns the index of first chunk that matches a set of criteria\n\nArguments\n\nchunks: an array of chunks\n\nKeywords\n\ncheck_value=true: \ncriteria: a set of keyword arguments for slot-value pairs\n\nExample\n\nchunks = [Chunk(animal=:dog), Chunk(animal=cat)]\nfind_index(chunks; animal=:dog)\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.find_indices-Tuple{ACTR, Vararg{Any}}","page":"api","title":"ACTRModels.find_indices","text":"find_indices(actr::ACTR, funs...; check_value=true, criteria...)\n\nReturns the index of first chunk that matches a set of criteria\n\nArguments\n\nactr: an ACTR object\nfuns: a set of functions\n\nKeywords\n\ncheck_value=true: \ncriteria: a set of keyword arguments for slot-value pairs\n\nExample\n\nchunks = [Chunk(animal=:dog), Chunk(animal=:dog), Chunk(animal=cat)]\nfind_indices(chunks; animal=:dog)\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.find_indices-Tuple{ACTR}","page":"api","title":"ACTRModels.find_indices","text":"find_indices(actr::ACTR; check_value = true, criteria...)\n\nReturns the index of first chunk that matches a set of criteria\n\nArguments\n\nactr: an ACTR object\ncriteria: a set of keyword arguments for slot-value pairs\n\nExample\n\nchunks = [Chunk(animal=:dog), Chunk(animal=:dog), Chunk(animal=cat)]\nfind_indices(chunks; animal=:dog)\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.find_indices-Tuple{Vector{<:Chunk}, Vararg{Any}}","page":"api","title":"ACTRModels.find_indices","text":"find_indices(chunks::Array{<:Chunk,1}, funs...; check_value=true, criteria...)\n\nReturns the index of first chunk that matches a set of criteria.\n\nArguments\n\nchunks: an array of chunks\nfuns: a set of functions\n\nKeywords\n\ncheck_value=true: \ncriteria: a set of keyword arguments for slot-value pairs\n\nExample\n\nchunks = [Chunk(animal=:dog), Chunk(animal=:dog), Chunk(animal=cat)]\nfind_indices(chunks; animal=:dog)\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.find_indices-Tuple{Vector{<:Chunk}}","page":"api","title":"ACTRModels.find_indices","text":"find_indices(chunks::Array{<:Chunk,1}; check_value=true, criteria...)\n\nReturns the index of first chunk that matches a set of criteria\n\nArguments\n\nchunks: an array of chunks\n\nKeywords\n\ncheck_value=true: \ncriteria: a set of keyword arguments for slot-value pairs\n\nExample\n\nchunks = [Chunk(animal=:dog), Chunk(animal=:dog), Chunk(animal=cat)]\nfind_indices(chunks; animal=:dog)\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.first_chunk-Tuple{AbstractACTR}","page":"api","title":"ACTRModels.first_chunk","text":"first_chunk(actr::AbstractACTR; check_value=true, criteria...)\n\nReturns the first chunk in memory that matches a set of criteria\n\nArguments\n\nactr::AbstractACTR: an ACT-R model object\n\nKeywords\n\ncheck_value=true: check slot value \ncriteria...: optional keyword arguments corresponding to critiria for matching chunk\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.first_chunk-Tuple{Declarative}","page":"api","title":"ACTRModels.first_chunk","text":"first_chunk(d::Declarative; criteria...)\n\nReturns the first chunk in memory that matches a set of criteria\n\nArguments\n\nd::Declarative: a declarative memory object\n\nKeywords\n\ncheck_value=true: check slot value \ncriteria...: optional keyword arguments corresponding to critiria for matching chunk\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.first_chunk-Tuple{Vector{<:Chunk}}","page":"api","title":"ACTRModels.first_chunk","text":"first_chunk(memory::Vector{<:Chunk}; check_value=true, criteria...)\n\nReturns the first chunk in memory that matches a set of criteria\n\nArguments\n\nmemory::Vector{<:Chunk}: a vector of chunks \n\nKeywords\n\ncheck_value=true: check slot value \ncriteria...: optional keyword arguments corresponding to critiria for matching chunk\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_buffer-Tuple{Any, Any}","page":"api","title":"ACTRModels.get_buffer","text":"get_buffer(actr, m)\n\nReturns posterior predictive distribution and optionally applies function to samples      on each replication\n\nArguments\n\nactr: an ACTR object\nm: name of module as a symbol\n\nExample\n\nget_buffer(actr, :imaginal)\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_chunks-Tuple{AbstractACTR, Vararg{Any}}","page":"api","title":"ACTRModels.get_chunks","text":"get_chunks(actr::AbstractACTR, funs...; check_value=true, criteria...)\n\nReturns all chunks that matches a set criteria using funs... as matching functions.\n\nArguments\n\nactr::AbstractACTR: an ACT-R model object\nfuns...: a list of functions\n\nKeywords\n\ncheck_value=true: check slot value \ncriteria...: optional keyword arguments corresponding to critiria for matching chunk\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_chunks-Tuple{AbstractACTR}","page":"api","title":"ACTRModels.get_chunks","text":"get_chunks(actr::AbstractACTR; check_value=true, criteria...)\n\nReturns all chunks that matches a set criteria\n\nArguments\n\nactr::AbstractACTR: an ACTR Object\n\n#Keywords\n\ncheck_value=true: check slot value \ncriteria...: optional keyword arguments corresponding to critiria for matching chunk\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_chunks-Tuple{Declarative, Vararg{Any}}","page":"api","title":"ACTRModels.get_chunks","text":"get_chunks(d::Declarative, funs...; check_value=true, criteria...)\n\nReturns all chunks that matches a set criteria using funs... as matching functions\n\nArguments\n\nd::Declarative: declarative memory object\nfuns...: a list of functions\n\nKeywords\n\ncheck_value=true: check slot value \ncriteria...: optional keyword arguments corresponding to critiria for matching chunk\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_chunks-Tuple{Declarative}","page":"api","title":"ACTRModels.get_chunks","text":"get_chunks(d::Declarative; check_value=true, criteria...)\n\nReturns all chunks that matches a set criteria.\n\nArguments\n\nd::Declarative: declarative memory object\n\nKeywords\n\ncheck_value=true: check slot value \ncriteria...: optional keyword arguments corresponding to critiria for matching chunk\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_chunks-Tuple{Vector{<:Chunk}, Vararg{Any}}","page":"api","title":"ACTRModels.get_chunks","text":"get_chunks(memory::Vector{<:Chunk}, funs...; check_value=true, criteria...)\n\nReturns all chunks that matches a set criteria which are evaluted according to the list of functions in funs.\n\nArguments\n\nmemory::Vector{<:Chunk}: vector of chunk objects\nfuns...: a list of functions\n\nKeywords\n\ncheck_value=true: check slot value \ncriteria...: optional keyword arguments corresponding to critiria for matching chunk\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_chunks-Tuple{Vector{<:Chunk}}","page":"api","title":"ACTRModels.get_chunks","text":"get_chunks(memory::Vector{<:Chunk}; check_value=true, criteria...)\n\nReturns all chunks that matches a set criteria.\n\nArguments\n\nmemory::Vector{<:Chunk}: vector of chunk objects\n\nKeywords\n\ncheck_value=true: check slot value \n\n-criteria...: optional keyword arguments corresponding to critiria for matching chunk\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_iconic_memory-Tuple{Any}","page":"api","title":"ACTRModels.get_iconic_memory","text":"get_iconic_memory(actr)\n\nReturns array of chunks or visual objects representing iconic memory \n\nArguments\n\nactr: an ACTR object\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_mean_activations-Tuple{AbstractACTR}","page":"api","title":"ACTRModels.get_mean_activations","text":"get_mean_activations(actr::AbstractACTR)\n\nReturns a vector of mean activations i.e. activation without noise\n\nArguments\n\nactr::AbstractACTR: an ACTR object\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_mean_activations-Tuple{Declarative}","page":"api","title":"ACTRModels.get_mean_activations","text":"get_mean_activations(declarative::Declarative)\n\nReturns a vector of mean activations i.e. activation without noise\n\nArguments\n\ndeclarative::Declarative: an Declarative memory object\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_mean_activations-Tuple{Vector{<:Chunk}}","page":"api","title":"ACTRModels.get_mean_activations","text":"get_mean_activations(chunks::Vector{<:Chunk})\n\nReturns a vector of mean activations i.e. activation without noise\n\nArguments\n\nchunks::Vector{<:Chunk}: an array of chunks\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_name-Tuple{AbstractACTR}","page":"api","title":"ACTRModels.get_name","text":"get_name(actr::AbstractACTR)\n\nReturns the name of an ACT-R model object. \n\nArguments\n\nactr::AbstractACTR: an ACTR model object\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_parm-Tuple{Any, Any}","page":"api","title":"ACTRModels.get_parm","text":"get_parm(actr, p)\n\nReturns the value of a parameter\n\nArguments\n\nactr: ACTR object\np: parameter name\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_time-Tuple{AbstractACTR}","page":"api","title":"ACTRModels.get_time","text":"get_time(actr::AbstractACTR)\n\nGet the current time of the simulation. \n\nArguments\n\nactr::AbstractACTR: an ACTR model object\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_time-Tuple{Any}","page":"api","title":"ACTRModels.get_time","text":"get_time(scheduler)\n\nGet the current time of the simulation. \n\nArguments\n\nscheduler: an event scheduler\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.get_visicon-Tuple{Any}","page":"api","title":"ACTRModels.get_visicon","text":"get_iconic_memory(actr)\n\nReturns array of chunks or visual objects representing all visual objects within the simulation\n\nArguments\n\nactr: an ACTR object\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.modify!-Tuple{Any}","page":"api","title":"ACTRModels.modify!","text":"modify!(c; args...)\n\nModifies fields of an object\n\nArguments\n\nc: an object\n\nKeywords\n\nargs...: optional keywords for field and values\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.modify!-Tuple{NamedTuple}","page":"api","title":"ACTRModels.modify!","text":"modify!(c::NamedTuple; args...)\n\nModifies fields of NamedTuple\n\nArguments\n\nc: a NamedTuple\n\nKeywords\n\nargs...: optional keywords for field and values\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.posterior_predictive","page":"api","title":"ACTRModels.posterior_predictive","text":"posterior_predictive(model, chain, n_samples::Int, f=x -> x)\n\nReturns posterior predictive distribution and optionally applies function to samples      on each replication\n\nmodel: the data generating function of a model \nchain: an MCMCChains chain object\nn_samples: the number of samples \nf: a function that is applied to each sample from posterior predictive distribution\n\n\n\n\n\n","category":"function"},{"location":"api/#ACTRModels.retrieval_prob-Tuple{AbstractACTR, Chunk, Any}","page":"api","title":"ACTRModels.retrieval_prob","text":"retrieval_prob(actr::AbstractACTR, chunk::Chunk, cur_time=0.0; request...)\n\nUses the softmax approximation to compute the retrieval probability of retrieving a chunk.\n\nArguments\n\nactr::AbstractACTR: an ACT-R object\nchunk::Chunk: a chunk\ncur_time: current simulated time in seconds\n\nKeywords\n\nrequest...: optional keyword pairs representing a retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.retrieval_prob-Tuple{AbstractACTR, Chunk}","page":"api","title":"ACTRModels.retrieval_prob","text":"retrieval_prob(actr::AbstractACTR, chunk::Chunk; request...)\n\nUses the softmax approximation to compute the retrieval probability of retrieving a chunk. By default, current time is computed from get_time.\n\nArguments\n\nactr::AbstractACTR: an ACT-R object\nchunk::Chunk: a chunk\n\nKeywords\n\nrequest...: optional keyword pairs representing a retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.retrieval_prob-Tuple{AbstractACTR, Vector{<:Chunk}, Any}","page":"api","title":"ACTRModels.retrieval_prob","text":"retrieval_prob(actr::AbstractACTR, target::Array{<:Chunk,1}, cur_time; request...)\n\nComputes the retrieval probability of one chunk from a set of chunks defined in target. Retrieval probability is computed with the softmax approximation.\n\nArguments\n\nactr::AbstractACTR: an actr object\ntarget::Array{<:Chunk,1}: a vector chunks in the numerator of the softmax function\ncur_time: current time in seconds\n\nKeywords\n\nrequest...: optional keywords for the retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.retrieval_prob-Tuple{AbstractACTR, Vector{<:Chunk}}","page":"api","title":"ACTRModels.retrieval_prob","text":"retrieval_prob(actr::AbstractACTR, target::Array{<:Chunk,1}; request...)\n\nUses the softmax approximation to compute the retrieval probability of retrieving a chunk. By default, current time is computed from get_time.\n\nArguments\n\nactr::AbstractACTR: an ACT-R object\ntarget::Array{<:Chunk,1}: a vector chunks in the numerator of the softmax function\n\nKeywords\n\nrequest...: optional keyword pairs representing a retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.retrieval_probs-Tuple{AbstractACTR, Any}","page":"api","title":"ACTRModels.retrieval_probs","text":"retrieval_probs(actr::AbstractACTR, cur_time; request...)\n\nComputes the retrieval probability for each chunk matching the retrieval request.\n\nArguments\n\nactr::AbstractACTR: an actr object\ncur_time: current simulated time in seconds\n\nKeywords\n\nrequest...: optional keyword pairs representing a retrieval request\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.retrieval_request-Tuple{AbstractACTR}","page":"api","title":"ACTRModels.retrieval_request","text":"retrieval_request(actr::AbstractACTR; request...)\n\nReturns chunks matching a retrieval request.\n\nArguments\n\nmemory: declarative memory object\n\nKeywords\n\nrequest...: optional keyword arguments corresponding to retrieval request e.g. dog = :fiddo\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.retrieve-Tuple{AbstractACTR, Any}","page":"api","title":"ACTRModels.retrieve","text":"retrieve(actr::AbstractACTR, cur_time; request...)\n\nRetrieves a chunk given a retrieval request\n\nArguments\n\nactr: an ACT-R object\ncur_time: current simulated time in seconds\n\nKeywords\n\nrequest...: optional keyword arguments representing a retrieval request, e.g. person=:bob\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.retrieve-Tuple{AbstractACTR}","page":"api","title":"ACTRModels.retrieve","text":"retrieve(actr::AbstractACTR; request...)\n\nRetrieves a chunk given a retrieval request. By default, current time is  computed with get_time.\n\nArguments\n\nactr: an ACT-R object\n\nKeywords\n\nrequest...: optional keyword arguments representing a retrieval request, e.g. person=:bob\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.set_buffer!-Tuple{Any, Any, Any}","page":"api","title":"ACTRModels.set_buffer!","text":"get_buffer(actr, m)\n\nReturns posterior predictive distribution and optionally applies function to samples      on each replication\n\nArguments\n\nactr: an ACTR object\nm: name of module as a symbol\nv: new value\n\nExample\n\nset_buffer!(actr, :imaginal, [chunk])\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.update_chunk!-Tuple{Any, Any}","page":"api","title":"ACTRModels.update_chunk!","text":"update_chunk!(chunk, cur_time)\n\nIncrements number of uses and adds cur_time as the most recent time of use.\n\nArguments\n\nchunk: a chunk object \n`cur_time': current simulated time in seconds \n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.update_lags!-Tuple{AbstractACTR, Any}","page":"api","title":"ACTRModels.update_lags!","text":"update_lags!(actr::AbstractACTR, cur_time)\n\nCompute lags for each use of a chunk. Applies to all chunks in declarative memory.\n\nArguments\n\nactr::AbstractACTR: an ACTR object\ncur_time: current simulated time in seconds\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.update_lags!-Tuple{Chunk, Any}","page":"api","title":"ACTRModels.update_lags!","text":"update_lags!(chunk::Chunk, cur_time)\n\nCompute lags for each use of a chunk.\n\nArguments\n\nchunk::Chunks: a chunk\ncur_time: current simulated time in seconds.\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.update_lags!-Tuple{Declarative, Any}","page":"api","title":"ACTRModels.update_lags!","text":"update_lags!(memory::Declarative, cur_time)\n\nCompute lags for each use of a chunk. Applies to all chunks in declarative memory.\n\nArguments\n\nmemory::Declarative: a declarative memory object object\ncur_time: current simulated time in seconds\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.update_recent!-Tuple{AbstractACTR, Any}","page":"api","title":"ACTRModels.update_recent!","text":"update_recent!(actr, chunk)\n\nAdds a new timestamp to chunk and removes oldest timestamp if length equals k. By default, current time is computed with get_time.\n\nArguments\n\nactr: an ACT-R model object \nchunk: memory chunk object\n\n\n\n\n\n","category":"method"},{"location":"api/#ACTRModels.update_recent!-Tuple{Any, Any}","page":"api","title":"ACTRModels.update_recent!","text":"update_recent!(chunk, cur_time)\n\nAdds a new timestamp to chunk and removes oldest timestamp if length equals k.\n\nArguments\n\nchunk: memory chunk object\ncur_time: current simulated time in seconds\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.match-Tuple{Chunk, Vararg{Any}}","page":"api","title":"Base.match","text":"match(chunk::Chunk, funs...; request...)\n\nReturns a boolean indicating whether a request matches a chunk. False is returned if the slot does not exist in the chunk or the value of the slot does not match the request value.\n\nchunk: chunk object\nfuns...: a list of functions such as !=, ==\nrequest...: a NamedTuple of slot value pairs\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.match-Tuple{Chunk}","page":"api","title":"Base.match","text":"match(chunk::Chunk; request...)\n\nReturns a boolean indicating whether a request matches a chunk. False is returned if the slot does not exist in the chunk or the value of the slot does not match the request value.\n\nArguments\n\nchunk::Chunk: a chunk object\n\nKeywords\n\nrequest...: optional keyword arguments corresponding to critiria for matching chunk\n\n\n\n\n\n","category":"method"},{"location":"example2/#Example-2","page":"example 2","title":"Example 2","text":"","category":"section"},{"location":"example2/","page":"example 2","title":"example 2","text":"using ACTRModels\nusing SequentialSamplingModels\nusing Random\nusing Plots\n\nRandom.seed!(87545)\n# create chunks of declarative knowledge\nchunks = [Chunk(;name=:Bob, department=:accounting),\n    Chunk(;name=:Alice, department=:HR)]\n\n# initialize declarative memory\ndeclarative = Declarative(memory=chunks)\n\n# specify model parameters: partial matching, noise, mismatch penalty, activation noise\nΘ = (mmp=true, noise=true, δ=1.0, s=.2)  \n\n# create an ACT-R object with activation noise and partial matching\nactr = ACTR(;declarative, Θ...)\n\n# retrieve a chunk associated with accounting\nchunk = retrieve(actr; department=:accounting)\n\nrt = compute_RT(actr, chunk)\n\n# index of retrieved chunk \nchunk_idx = find_index(chunk)\n# compute activation for each chunk\ncompute_activation!(actr; department=:accounting)\n# get mean activation\nμ = get_mean_activations(actr)\n# standard deviation \nσ = Θ.s * pi / sqrt(3)\n# lognormal race distribution object\ndist = LNR(;μ=-μ, σ, ϕ=0.0)\n# log pdf of retrieval time\nlogpdf(dist, chunk_idx, rt)","category":"page"},{"location":"example2/","page":"example 2","title":"example 2","text":"The purpose of this example is to develop a likelihood function for retrieval time using an evidence accumulation modeld called Log Normal Race model. ","category":"page"},{"location":"example2/#Generate-Simulated-Data","page":"example 2","title":"Generate Simulated Data","text":"","category":"section"},{"location":"example2/","page":"example 2","title":"example 2","text":"The first step is to develop a model and generate simulated data based on Example 1. The code for Example 1 is reproduced below:","category":"page"},{"location":"example2/","page":"example 2","title":"example 2","text":"using ACTRModels\nusing SequentialSamplingModels\nusing Random\nusing Plots\n\nRandom.seed!(87545)\n# create chunks of declarative knowledge\nchunks = [Chunk(;name=:Bob, department=:accounting),\n    Chunk(;name=:Alice, department=:HR)]\n\n# initialize declarative memory\ndeclarative = Declarative(memory=chunks)\n\n# specify model parameters: partial matching, noise, mismatch penalty, activation noise\nΘ = (mmp=true, noise=true, δ=1.0, s=.2)  \n\n# create an ACT-R object with activation noise and partial matching\nactr = ACTR(;declarative, Θ...)\n\n# retrieve a chunk associated with accounting\nchunk = retrieve(actr; department=:accounting)\n\n# compute retrieval time\nrt = compute_RT(actr, chunk)","category":"page"},{"location":"example2/#Compute-Log-Likelihood","page":"example 2","title":"Compute Log Likelihood","text":"","category":"section"},{"location":"example2/","page":"example 2","title":"example 2","text":"Now that we have simulated data, we can compute the log likelihood of retrieving the chunk after the observed number of seconds. First, we need to identify the chunk index:","category":"page"},{"location":"example2/#Chunk-Index","page":"example 2","title":"Chunk Index","text":"","category":"section"},{"location":"example2/","page":"example 2","title":"example 2","text":"# index of retrieved chunk \nchunk_idx = find_index(chunk)","category":"page"},{"location":"example2/#Compute-Mean-Activation","page":"example 2","title":"Compute Mean Activation","text":"","category":"section"},{"location":"example2/","page":"example 2","title":"example 2","text":"Next, we will compute activation with the function compute_activation! and extract a vector of mean activations for the Log Normal Race. ","category":"page"},{"location":"example2/","page":"example 2","title":"example 2","text":"# compute activation for each chunk\ncompute_activation!(actr; department=:accounting)\n# get mean activation\nμ = get_mean_activations(actr)","category":"page"},{"location":"example2/#Compute-Activation-Standard-Deviation","page":"example 2","title":"Compute Activation Standard Deviation","text":"","category":"section"},{"location":"example2/","page":"example 2","title":"example 2","text":"The standard deviation for activation is computed as follows","category":"page"},{"location":"example2/","page":"example 2","title":"example 2","text":"# standard deviation \nσ = Θ.s * pi / sqrt(3)","category":"page"},{"location":"example2/#Construct-Distribution-Object","page":"example 2","title":"Construct Distribution Object","text":"","category":"section"},{"location":"example2/","page":"example 2","title":"example 2","text":"Next, we will create a distribution object for the Log Normal Race model as follows","category":"page"},{"location":"example2/","page":"example 2","title":"example 2","text":"# lognormal race distribution object\ndist = LNR(;μ=-μ, σ, ϕ=0.0)","category":"page"},{"location":"example2/#Compute-Log-Likelihood-2","page":"example 2","title":"Compute Log Likelihood","text":"","category":"section"},{"location":"example2/","page":"example 2","title":"example 2","text":"Finally, we can use logpdf to compute the log likelihood of the retrieved chunk:","category":"page"},{"location":"example2/","page":"example 2","title":"example 2","text":"# log pdf of retrieval time\nlogpdf(dist, chunk_idx, rt)","category":"page"},{"location":"example2/#PDF-Overlay","page":"example 2","title":"PDF Overlay","text":"","category":"section"},{"location":"example2/","page":"example 2","title":"example 2","text":"One way to verify the likelihood function works is to overlay the PDF on a histogram of simulated data (both based on the same parameters). As expected, the orange line, which represents the PDF, fits the grey histogram well.","category":"page"},{"location":"example2/","page":"example 2","title":"example 2","text":"# index for accounting\nidx = find_index(actr; department=:accounting)\n# generate retrieval times\nchoices,rts = rand(dist, 10^5)\n# extract rts for accounting\nacc_rts = rts[choices .== idx]\n# probability of retrieving accounting\np_acc = length(acc_rts)/length(rts)\n# histogram of retrieval times\nhist = histogram(acc_rts, color=:grey, leg=false, grid=false, size=(500,300),\n    bins = 100, norm=true, xlabel=\"Retrieval Time\", ylabel=\"Density\")\n# weight histogram according to retrieval probability\nhist[1][1][:y] *= p_acc\n# collection of retrieval time values\nx = 0:.01:3\n# density for each x value\ndens = pdf.(dist, idx, x)\n# overlay PDF on histogram\nplot!(hist, x, dens, color=:darkorange, linewidth=1.5, xlims=(0,3))","category":"page"},{"location":"example2/#References","page":"example 2","title":"References","text":"","category":"section"},{"location":"example2/","page":"example 2","title":"example 2","text":"Fisher, C. R., Houpt, J. W., & Gunzelmann, G. (2022). Fundamental tools for developing likelihood functions within ACT-R. Journal of Mathematical Psychology, 107, 102636.","category":"page"},{"location":"example2/","page":"example 2","title":"example 2","text":"Rouder, J. N., Province, J. M., Morey, R. D., Gomez, P., & Heathcote, A. (2015). The lognormal race: A cognitive-process model of choice and latency with desirable psychometric properties. Psychometrika, 80, 491-513.","category":"page"},{"location":"example3/#Example-3","page":"example 3","title":"Example 3","text":"","category":"section"},{"location":"example3/","page":"example 3","title":"example 3","text":"using ACTRModels\nusing SequentialSamplingModels\nusing Random\nusing Plots\n\nRandom.seed!(87545)\n# create chunks of declarative knowledge\nchunks = [Chunk(;option=1, value=4.0, bl=1.6),\n        Chunk(;option=1, value=2.0, bl=1.5),\n        Chunk(;option=2, value=3.5, bl=1.2),\n        Chunk(;option=2, value=4.0, bl=1.6),\n        Chunk(;option=3, value=2.0, bl=1.0),\n        Chunk(;option=3, value=3.0, bl=1.75)]\n\n# initialize declarative memory\ndeclarative = Declarative(memory=chunks)\n\n# specify model parameters: partial matching, noise, mismatch penalty, activation noise\nΘ = (mmp=true, noise=true, δ=1.0, s=.2)  \n\n# create an ACT-R object with activation noise and partial matching\nactr = ACTR(;declarative, Θ...)\n\nn_sim = 10_000\nblended_slots = :value\n\nrequest = (option=1,)\nblended_values1 = map(_ -> blend_chunks(actr, blended_slots; request...), 1:n_sim)\n\nrequest = (option=2,)\nblended_values2 = map(_ -> blend_chunks(actr, blended_slots; request...), 1:n_sim)\n\nrequest = (option=3,)\nblended_values3 = map(_ -> blend_chunks(actr, blended_slots; request...), 1:n_sim)\n\nhistogram(blended_values1, norm=true, xlabel=\"Blended Values\", ylabel=\"Density\", label=\"Option 1\", alpha=.70)\nhistogram!(blended_values2, norm=true, xlabel=\"Blended Values\", ylabel=\"Density\", label=\"Option 2\", alpha=.70)\nhistogram!(blended_values3, norm=true, xlabel=\"Blended Values\", ylabel=\"Density\", label=\"Option 3\", alpha=.70)","category":"page"},{"location":"example3/","page":"example 3","title":"example 3","text":"The purpose of this example is to develop a likelihood function for retrieval time using an evidence accumulation modeld called Log Normal Race model. ","category":"page"},{"location":"example3/#Load-Packages","page":"example 3","title":"Load Packages","text":"","category":"section"},{"location":"example3/","page":"example 3","title":"example 3","text":"The first step is to develop a model and generate simulated data based on Example 1. The code for Example 1 is reproduced below:","category":"page"},{"location":"example3/","page":"example 3","title":"example 3","text":"using ACTRModels\nusing Random\nusing Plots\n\nRandom.seed!(87545)","category":"page"},{"location":"example3/#Define-Parameters","page":"example 3","title":"Define Parameters","text":"","category":"section"},{"location":"example3/","page":"example 3","title":"example 3","text":"# specify model parameters: partial matching, noise, mismatch penalty, activation noise\nΘ = (mmp=true, noise=true, δ=1.0, s=0.20)  ","category":"page"},{"location":"example3/#Populate-Declarative-Memory","page":"example 3","title":"Populate Declarative Memory","text":"","category":"section"},{"location":"example3/","page":"example 3","title":"example 3","text":"# create chunks of declarative knowledge\nchunks = [Chunk(;option=1, value = 4.0, bl=1.6),\n        Chunk(;option=1, value = 2.0, bl=1.5),\n        Chunk(;option=2, value = 3.5, bl=1.2),\n        Chunk(;option=2, value = 4.0, bl=1.6),\n        Chunk(;option=3, value = 2.0, bl=1.0),\n        Chunk(;option=3, value = 3.0, bl=1.75)]\n# initialize declarative memory\ndeclarative = Declarative(memory=chunks)","category":"page"},{"location":"example3/","page":"example 3","title":"example 3","text":"# create an ACT-R object with activation noise and partial matching\nactr = ACTR(;declarative, Θ...)","category":"page"},{"location":"example3/#Run-Simulation","page":"example 3","title":"Run Simulation","text":"","category":"section"},{"location":"example3/","page":"example 3","title":"example 3","text":"n_sim = 10_000\nblended_slots = :value\n\nrequest = (option=1,)\nblended_values1 = map(_ -> blend_chunks(actr, blended_slots; request...), 1:n_sim)\n\nrequest = (option=2,)\nblended_values2 = map(_ -> blend_chunks(actr, blended_slots; request...), 1:n_sim)\n\nrequest = (option=3,)\nblended_values3 = map(_ -> blend_chunks(actr, blended_slots; request...), 1:n_sim)","category":"page"},{"location":"example3/#Plot-Results","page":"example 3","title":"Plot Results","text":"","category":"section"},{"location":"example3/","page":"example 3","title":"example 3","text":"histogram(blended_values1, norm=true, xlabel=\"Blended Values\", ylabel=\"Density\", label=\"Option 1\", alpha=.75)\nhistogram!(blended_values2, norm=true, xlabel=\"Blended Values\", ylabel=\"Density\", label=\"Option 2\", alpha=.75)\nhistogram!(blended_values3, norm=true, xlabel=\"Blended Values\", ylabel=\"Density\", label=\"Option 3\", alpha=.75)","category":"page"},{"location":"example1/#Example-1","page":"example 1","title":"Example 1","text":"","category":"section"},{"location":"example1/","page":"example 1","title":"example 1","text":"This example will demonstrate how to create memory chunks, add them to the model, perform a memory retrieval, and compute the retrieval time. Declarative memory will consist of two chunks representing two co-workers and their departments: ","category":"page"},{"location":"example1/","page":"example 1","title":"example 1","text":"mathbfc_1 = (mathrmnameBob)(mathrmdepartmentaccounting)  \n\nmathbfc_2 = (mathrmnameAlice)(mathrmdepartmentHR) ","category":"page"},{"location":"example1/","page":"example 1","title":"example 1","text":"using ACTRModels\nusing Random\nusing Plots\n\nRandom.seed!(87545)\n# create chunks of declarative knowledge\nchunks = [Chunk(;name=:Bob, department=:accounting),\n    Chunk(;name=:Alice, department=:HR)]\n\n# initialize declarative memory\ndeclarative = Declarative(memory=chunks)\n\n# specify model parameters: partial matching, noise, mismatch penalty, activation noise\nΘ = (mmp=true, noise=true, δ=1.0, s=.2)  \n\n# create an ACT-R object with activation noise and partial matching\nactr = ACTR(;declarative, Θ...)","category":"page"},{"location":"example1/#Create-Chunks","page":"example 1","title":"Create Chunks","text":"","category":"section"},{"location":"example1/","page":"example 1","title":"example 1","text":"The first step is to load the required packages. Next, we set a seed for the random number generator. Finally, we can create a vector of chunks using the Chunk constructor. Constructor accepts a variable number of keyword arguments as slot-value pairs.","category":"page"},{"location":"example1/","page":"example 1","title":"example 1","text":"using ACTRModels\nusing Random\nusing Plots\n\nRandom.seed!(87545)\n# create chunks of declarative knowledge\nchunks = [Chunk(;name=:Bob, department=:accounting),\n    Chunk(;name=:Alice, department=:HR)]","category":"page"},{"location":"example1/#Create-a-Model","page":"example 1","title":"Create a Model","text":"","category":"section"},{"location":"example1/","page":"example 1","title":"example 1","text":"After creating the chunks, the next step is to pass them to the constructor Declarative to create a declarative memory object. In the next line, we specify a NamedTuple of parameters. Finally, the declarative memory object and the parameters are passed to the ACTR constructor to generate an ACT-R model object.","category":"page"},{"location":"example1/","page":"example 1","title":"example 1","text":"# initialize declarative memory\ndeclarative = Declarative(memory=chunks)\n\n# specify model parameters: partial matching, noise, mismatch penalty, activation noise\nΘ = (mmp=true, noise=true, δ=1.0, s=.2)  \n\n# create an ACT-R object with activation noise and partial matching\nactr = ACTR(;declarative, Θ...)","category":"page"},{"location":"example1/#Retrieve-Chunk","page":"example 1","title":"Retrieve Chunk","text":"","category":"section"},{"location":"example1/","page":"example 1","title":"example 1","text":"To retrieve a chunk, pass the ACT-R model objec to the function retrieve along with keyword arguments for the retrieval request. retrieve will return a vector containing a chunk or an empty vector indicating a retrieval failure.","category":"page"},{"location":"example1/","page":"example 1","title":"example 1","text":"# retrieve a chunk associated with accounting\nchunk = retrieve(actr; department=:accounting)","category":"page"},{"location":"example1/#Compute-Retrieval-Time","page":"example 1","title":"Compute Retrieval Time","text":"","category":"section"},{"location":"example1/","page":"example 1","title":"example 1","text":"Retrieval time is computed by passing the ACT-R model object and the retried vector to the function compute_RT. If the vector chunk is empty, the retrieval failure time will be based on the retrieval threshold, τ.","category":"page"},{"location":"example1/","page":"example 1","title":"example 1","text":"rt = compute_RT(actr, chunk)","category":"page"},{"location":"example1/#References","page":"example 1","title":"References","text":"","category":"section"},{"location":"example1/","page":"example 1","title":"example 1","text":"Anderson, J. R., Bothell, D., Byrne, M. D., Douglass, S., Lebiere, C., & Qin, Y. (2004). An integrated theory of the mind. Psychological review, 111(4), 1036.","category":"page"},{"location":"#Introduction","page":"home","title":"Introduction","text":"","category":"section"},{"location":"","page":"home","title":"home","text":"The goal of this package is to provide basic functions and types for building models based on the ACT-R cognitive architecture. More documentation to follow.","category":"page"},{"location":"#Related-Packages","page":"home","title":"Related Packages","text":"","category":"section"},{"location":"#ACTRTutorials","page":"home","title":"ACTRTutorials","text":"","category":"section"},{"location":"","page":"home","title":"home","text":"ACTRTutorials.jl is a collection of tutorials for developing analytic likelihood functions for ACTR models.","category":"page"},{"location":"#ACTRSimulators","page":"home","title":"ACTRSimulators","text":"","category":"section"},{"location":"","page":"home","title":"home","text":"ACTRSimulators.jl is an experimental package for performing \"classic\" discrete event simulations with ACT-R.","category":"page"},{"location":"#References","page":"home","title":"References","text":"","category":"section"},{"location":"","page":"home","title":"home","text":"Anderson, J. R., Bothell, D., Byrne, M. D., Douglass, S., Lebiere, C., & Qin, Y. (2004). An integrated theory of the mind. Psychological review, 111(4), 1036.","category":"page"}]
}
